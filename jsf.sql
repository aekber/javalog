CREATE DATABASE  IF NOT EXISTS `jsf` /*!40100 DEFAULT CHARACTER SET utf8 */;
USE `jsf`;
-- MySQL dump 10.13  Distrib 5.6.11, for Win32 (x86)
--
-- Host: localhost    Database: jsf
-- ------------------------------------------------------
-- Server version	5.5.33

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article` (
  `articleid` int(11) NOT NULL AUTO_INCREMENT,
  `subcategoryid` int(11) DEFAULT NULL,
  `iscommentsactive` tinyint(1) DEFAULT '1',
  `popularity` int(11) DEFAULT '0',
  `articletag` varchar(100) CHARACTER SET utf8 DEFAULT NULL,
  `previewstar` int(11) NOT NULL,
  `preview` mediumtext CHARACTER SET utf8,
  `content` mediumtext CHARACTER SET utf8 NOT NULL,
  `insertdate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`articleid`)
) ENGINE=InnoDB AUTO_INCREMENT=2117 DEFAULT CHARSET=utf8 COLLATE=utf8_turkish_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (2101,3101,1,23,'Generics',5,'A Set is a special kind of Collection, a SortedSet is a special kind of Set, and so forth. <h2>Note also that the hierarchy consists of two distinct trees — a Map is not a true Collection. \r\nNote that all the core collection interfaces are generic. For example, this is the declaration of the Collection interface. </h2>','A Set is a special kind of Collection, a SortedSet is a special kind of Set, and so forth. Note also that the hierarchy consists of two distinct trees — a Map is not a true Collection. \r\nNote that all the core collection interfaces are generic. For example, this is the declaration of the Collection interface. \r\n,page,\r\npublic interface Collection<E>...\r\n\r\nThe <E> syntax tells you that the interface is generic. When you declare a Collection instance you can and should specify the type of object contained in the collection. Specifying the type allows the compiler to verify (at compile-time) that the type of object you put into the collection is correct, thus reducing errors at runtime. For information on generic types, see the Generics lesson. \r\n\r\nWhen you understand how to use these interfaces, you will know most of what there is to know about the Java Collections Framework. This chapter discusses general guidelines for effective use of the interfaces, including when to use which interface. You\'ll also learn programming idioms for each interface to help you get the most out of it. \r\n\r\nTo keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. \r\n\r\nThe following list describes the core collection interfaces: \r\n\r\nCollection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. \r\n\r\nSet — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. \r\n\r\nList — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. \r\n\r\nQueue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. \r\nQueues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. \r\n\r\n\r\nMap — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. \r\nThe last two core collection interfaces are merely sorted versions of Set and Map: \r\nSortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. \r\n\r\nSortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. \r\nTo understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section','2010-11-13 21:36:51'),(2102,3101,1,25,'HashMap',6,'Directory Package\r\nThe javax.naming package to provide functionality for accessing directory services in addition to naming services. This package allows applications to retrieve associated with objects stored in the directory and to search for objects using specified attributes. ','Directory Package\r\nThe javax.naming package to provide functionality for accessing directory services in addition to naming services. This package allows applications to retrieve associated with objects stored in the directory and to search for objects using specified attributes. \r\nThe Directory Context\r\nThe DirContextinterface represents a directory context. DirContext also behaves as a naming context by extending the getAttributes()to retrieve the attributes associated with a directory entry (for which you supply the name). Attributes are modified using modifyAttributes()method. Other overloaded forms of search()support more sophisticated search filters. \r\n\r\nLDAP Package\r\nThe javax.naming.ldap package contains classes and interfaces for using features that are specific to the LDAP v3 that are not already covered by the more generic javax.naming.directory package. In fact, most JNDI applications that use the LDAP will find the javax.naming.directory package sufficient and will not need to use the javax.naming.ldap package at all. This package is primarily for those applications that need to use \"extended\" operations, controls, or unsolicited notifications. \r\n\r\n\"Extended\" Operation \r\nIn addition to specifying well defined operations such as search and modify, the LDAP v3 (RFC 2251) specifies a way to transmit yet-to-be defined operations between the LDAP client and the server. These operations are called \"extended\" operations. An \"extended\" operation may be defined by a standards organization such as the Internet Engineering Task Force (IETF) or by a vendor. \r\nControls \r\nThe LDAP v3 allows any request or response to be augmented by yet-to-be defined modifiers, called controls . A control sent with a request is a request control and a control sent with a response is a response control . A control may be defined by a standards organization such as the IETF or by a vendor. Request controls and response controls are not necessarily paired, that is, there need not be a response control for each request control sent, and vice versa. \r\n\r\nUnsolicited Notifications \r\nIn addition to the normal request/response style of interaction between the client and server, the LDAP v3 also specifies unsolicited notifications--messages that are sent from the server to the client asynchronously and not in response to any client request. \r\nThe LDAP Context\r\nThe LdapContextinterface represents a context for performing \"extended\" operations, sending request controls, and receiving response controls. Examples of how to use these features are described in the JNDI Tutorial\'s Controls and Extensions lesson. \r\n\r\n','2010-10-13 20:37:23'),(2103,3102,1,58,'BufferedWriter',6,'Advantages of Dynamic Code Loading\r\nOne of the central and unique features of RMI is its ability to download the definition of an object\'s class if the class is not defined in the receiver\'s Java virtual machine. All of the types and behavior of an object, previously available only in a single Java virtual machine, can be transmitted to another, possibly remote, Java virtual machine. ','Advantages of Dynamic Code Loading\r\nOne of the central and unique features of RMI is its ability to download the definition of an object\'s class if the class is not defined in the receiver\'s Java virtual machine. All of the types and behavior of an object, previously available only in a single Java virtual machine, can be transmitted to another, possibly remote, Java virtual machine. RMI passes objects by their actual classes, so the behavior of the objects is not changed when they are sent to another Java virtual machine. This capability enables new types and behaviors to be introduced into a remote Java virtual machine, thus dynamically extending the behavior of an application. The compute engine example in this trail uses this capability to introduce new behavior to a distributed program. \r\nRemote Interfaces, Objects, and Methods\r\nLike any other Java application, a distributed application built by using Java RMI is made up of interfaces and classes. The interfaces declare methods. The classes implement the methods declared in the interfaces and, perhaps, declare additional methods as well. In a distributed application, some implementations might reside in some Java virtual machines but not others. Objects with methods that can be invoked across Java virtual machines are called remote objects. \r\nAn object becomes remote by implementing a remote interface, which has the following characteristics: \r\n\r\nA remote interface extends the interface java.rmi.Remote. \r\nEach method of the interface declares java.rmi.RemoteException in its throws clause, in addition to any application-specific exceptions. \r\nRMI treats a remote object differently from a non-remote object when the object is passed from one Java virtual machine to another Java virtual machine. Rather than making a copy of the implementation object in the receiving Java virtual machine, RMI passes a remote stub for a remote object. The stub acts as the local representative, or proxy, for the remote object and basically is, to the client, the remote reference. The client invokes a method on the local stub, which is responsible for carrying out the method invocation on the remote object. \r\n\r\nA stub for a remote object implements the same set of remote interfaces that the remote object implements. This property enables a stub to be cast to any of the interfaces that the remote object implements. However, only those methods defined in a remote interface are available to be called from the receiving Java virtual machine. \r\n\r\nCreating Distributed Applications by Using RMI\r\nUsing RMI to develop a distributed application involves these general steps: \r\nDesigning and implementing the components of your distributed application. \r\nCompiling sources. \r\nMaking classes network accessible. \r\nStarting the application. \r\nDesigning and Implementing the Application Components\r\nFirst, determine your application architecture, including which components are local objects and which components are remotely accessible. This step includes: \r\nDefining the remote interfaces. A remote interface specifies the methods that can be invoked remotely by a client. Clients program to remote interfaces, not to the implementation classes of those interfaces. The design of such interfaces includes the determination of the types of objects that will be used as the parameters and return values for these methods. If any of these interfaces or classes do not yet exist, you need to define them as well. \r\nImplementing the remote objects. Remote objects must implement one or more remote interfaces. The remote object class may include implementations of other interfaces and methods that are available only locally. If any local classes are to be used for parameters or return values of any of these methods, they must be implemented as well. \r\nImplementing the clients. Clients that use remote objects can be implemented at any time after the remote interfaces are defined, including after the remote objects have been deployed. \r\nCompiling Sources\r\nAs with any Java program, you use the javac compiler to compile the source files. The source files contain the declarations of the remote interfaces, their implementations, any other server classes, and the client classes. \r\n\r\n--------------------------------------------------------------------------------\r\nNote: With versions prior to Java Platform, Standard Edition 5.0, an additional step was required to build stub classes, by using the rmic compiler. However, this step is no longer necessary. \r\n--------------------------------------------------------------------------------\r\n\r\nMaking Classes Network Accessible\r\nIn this step, you make certain class definitions network accessible, such as the definitions for the remote interfaces and their associated types, and the definitions for classes that need to be downloaded to the clients or servers. Classes definitions are typically made network accessible through a web server. \r\nStarting the Application\r\nStarting the application includes running the RMI remote object registry, the server, and the client. \r\nThe rest of this section walks through the steps used to create a compute engine. \r\n\r\nBuilding a Generic Compute Engine\r\nThis trail focuses on a simple, yet powerful, distributed application called a compute engine. The compute engine is a remote object on the server that takes tasks from clients, runs the tasks, and returns any results. The tasks are run on the machine where the server is running. This type of distributed application can enable a number of client machines to make use of a particularly powerful machine or a machine that has specialized hardware. \r\nThe novel aspect of the compute engine is that the tasks it runs do not need to be defined when the compute engine is written or started. New kinds of tasks can be created at any time and then given to the compute engine to be run. The only requirement of a task is that its class implement a particular interface. The code needed to accomplish the task can be downloaded by the RMI system to the compute engine. Then, the compute engine runs the task, using the resources on the machine on which the compute engine is running. \r\n\r\nThe ability to perform arbitrary tasks is enabled by the dynamic nature of the Java platform, which is extended to the network by RMI. RMI dynamically loads the task code into the compute engine\'s Java virtual machine and runs the task without prior knowledge of the class that implements the task. Such an application, which has the ability to download code dynamically, is often called a behavior-based application. Such applications usually require full agent-enabled infrastructures. With RMI, such applications are part of the basic mechanisms for distributed computing on the Java platform. \r\n\r\n','2010-12-13 21:37:35'),(2104,3102,1,55,'FileReader',7,'Passing action parameters from JSF to backing beans\r\nThis can be done in several ways, with f:setPropertyActionListener, f:attribute and f:param.','Passing action parameters from JSF to backing beans\r\nThis can be done in several ways, with f:setPropertyActionListener, f:attribute and f:param.\r\n\r\nf:setPropertyActionListener: with the h:commandLink and h:commandButton tags you can trigger a method of the backing bean using the action or the actionListener attribute. As you cannot directly pass some method parameters from the JSF to the backing bean, the f:setPropertyActionListener tag might be very useful to dynamically set the bean properties which can be used as parameters. This works in JSF 1.2 or newer only. Here is an example:\r\n\r\n\r\n<h:form>\r\n    <h:commandLink value=\"Click here\" action=\"#{myBean.action}\">\r\n        <f:setPropertyActionListener target=\"#{myBean.propertyName1}\" value=\"propertyValue1\" />\r\n        <f:setPropertyActionListener target=\"#{myBean.propertyName2}\" value=\"propertyValue2\" />\r\n    </h:commandLink>\r\n\r\n    <h:commandButton value=\"Press here\" action=\"#{myBean.action}\">\r\n        <f:setPropertyActionListener target=\"#{myBean.propertyName1}\" value=\"propertyValue1\" />\r\n        <f:setPropertyActionListener target=\"#{myBean.propertyName2}\" value=\"propertyValue2\" />\r\n    </h:commandButton>\r\n</h:form>','2010-09-14 13:15:59'),(2105,3103,1,547,'Interfaces',6,'First, index.jsp (shown in Scriptlet 1) checks whether the list of books to be sold is available\r\nand, if it isn’t, it passes the control to the servlet, which then must initialize the book list.\r\nIn reality, the book list would be very long and kept in a database. Note that JSP doesn’t need','First, index.jsp (shown in Scriptlet 1) checks whether the list of books to be sold is available\r\nand, if it isn’t, it passes the control to the servlet, which then must initialize the book list.\r\nIn reality, the book list would be very long and kept in a database. Note that JSP doesn’t need\r\nto know where the list is kept. This is the first hint at the fact that application logic and presentation\r\nare separate. You’ll see later how the servlet fills in the book list and returns control\r\nto index.jsp. For now, let’s proceed with the analysis of the home page.\r\nIf Scriptlet 1 discovers that the book list exists, it copies it into the select control one by\r\none (as shown in Scriptlet 2). Notice how JSP simply creates each option by writing to the out\r\nstream. When the buyer clicks on the Add to Cart button after selecting a title and setting the\r\nnumber of copies, the home page posts a request to the servlet with the address eshop and\r\nwith the hidden parameter do_this set to add. Once more, the servlet takes care of updating or\r\ncreating the shopping cart by instantiating the class Book for each new book added to the cart.\r\nThis is application logic, not presentation of information.\r\nScriptlet 3 checks whether a shopping cart exists. index.jsp, being completely datadriven,\r\ndoesn’t remember what has happened before, so it runs every time from the\r\nbeginning. Therefore, it checks for the presence of a shopping cart even when the buyer\r\nsees the book list for the very first time.\r\nScriptlet 4 displays the items in the shopping cart, each one with its own form. If the\r\nbuyer decides to delete an entry, index.jsp sends a request to the servlet with the hidden\r\nparameter do_this set to remove.\r\nThe sole purpose of the last two scriptlets is to close the curly brackets of ifs and fors.\r\nHowever, notice that the form to ask the servlet to do the checkout is only displayed to the\r\nbuyer when the shopping cart isn’t empty. If the buyer clicks on the Checkout button,\r\nindex.jsp will send a request to the servlet with the hidden parameter do_this set to\r\ncheckout.','2010-08-14 13:15:59'),(2106,3104,1,210,'Aspects',4,'Finally, notice that some elements enclosed within <%= and %> are mixed inside the\r\nnormal HTML. They are <%=i%>, <%=aBook.getTitle()%>, <%=aBook.getPrice()%>, and\r\n<%=aBook.getQuantity()%>. These elements let you embed values resulting from JSP expressions\r\nin HTML without having to execute scriptlets.','Finally, notice that some elements enclosed within <%= and %> are mixed inside the\r\nnormal HTML. They are <%=i%>, <%=aBook.getTitle()%>, <%=aBook.getPrice()%>, and\r\n<%=aBook.getQuantity()%>. These elements let you embed values resulting from JSP expressions\r\nin HTML without having to execute scriptlets. The first expression, <%=i%>, is the\r\nposition of the book within the shopping cart. The other three are the execution of methods\r\nof an object of type Book, which the servlet instantiated for each new book added to the cart.\r\nYou’ve probably noticed that the address shown in the browser is http://localhost:8080/\r\nebookshop/eshop. This is actually the address of the Java servlet that controls the application.','2010-08-14 13:15:59'),(2107,3104,1,45,'Pointcuts',9,'What Role Does Tomcat Play in All This?\r\nTomcat is what makes the Ebookshop application accessible over the Internet. Its latest\r\nrelease (6.0) implements JSP 2.1 and EL 2.1. It obviously requires the Java SE 5 runtime environment,\r\nbecause older releases don’t include the correct versions of JSP and EL. ','What Role Does Tomcat Play in All This?\r\nTomcat is what makes the Ebookshop application accessible over the Internet. Its latest\r\nrelease (6.0) implements JSP 2.1 and EL 2.1. It obviously requires the Java SE 5 runtime environment,\r\nbecause older releases don’t include the correct versions of JSP and EL. The beauty\r\nof Tomcat is that it also includes its own HTTP server, so you don’t need anything else to\r\nhandle client requests.\r\nRather than providing abstract and general explanations, we’ll use the Ebookshop example\r\nto tell you what to do in practice.You have to organize the following files: index.jsp,\r\nCheckout.jsp, ShoppingServlet.java, and Book.java. First, create the folder structure shown in\r\nFigure 1-11 in C:\\Program Files\\Apache Software Foundation\\Tomcat 6.0\\webapps\\, and place\r\nyour four source files as indicated (see Appendix A for the installation procedure of Tomcat).\r\nFigure 1-11. The Ebookshop folder structure','2010-08-14 13:15:59'),(2108,3108,0,66,'Advices',5,'You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','JSP Explained\r\nIn the previous chapter, we placed JSP in the context of web applications, described JSP in\r\ngeneric terms, and showed a couple of examples. In this chapter, we’ll briefly introduce all\r\nthe JSP components and then jump into more interesting examples. For more details on the\r\nJSP components, please refer to Appendix D. At the end of this chapter, we’ll show you an\r\nalternative syntax for JSP pages, which makes them 100% XML-compliant.\r\nIntroduction\r\nIn Chapter 1’s simple hello.jsp example (shown in Listing 1-3), you saw that\r\nrequest.getHeader(\"user-agent\") returns a string that describes the client’s web browser.\r\nDespite the fact that the variable request isn’t defined anywhere, this works because Tomcat\r\ndefines several implicit variables: application, config, out, pageContext, request, response,\r\nand session. The most commonly used are out and request, followed by application and\r\nsession.\r\nThis first line of hello.jsp is an example of a directive element, another component\r\nof JSP:\r\n<%@page language=\"java\" contentType=\"text/html\"%>\r\nDirectives provide Tomcat with information it needs to translate the JSP page. As such,\r\ndirectives are independent of specific requests. Besides page, other available directives are\r\ninclude and taglib.\r\nIn Chapter 1, we didn’t show you any example of a standard action, another component\r\nof JSP. The purpose of standard actions is to encapsulate activities that Tomcat\r\nperforms when handling an HTTP request from a client. There are more than a dozen\r\nstandard actions: attribute, body, element, fallback, forward, getProperty, include, param,\r\nparams, plugin, setProperty, text, and useBean. For example, the following standard action\r\nincludes in a JSP page the output of another JSP:\r\n<jsp:include page=\"another.jsp\"/>\r\nThe hello.jsp example also includes another JSP component, a scripting element, which\r\nis a scriptlet delimited by the pair <% and %>. All scripting elements consist of code delimited\r\nby particular sequences of characters.\r\nEL is a JSP component that gives you easy access to external objects (i.e. Java beans).\r\n25','2010-09-14 13:16:00'),(2109,3105,1,101,'Security',6,'You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','2011-04-30 23:04:24'),(2110,3107,1,60,'WS-Basics',7,'You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','2011-02-01 10:06:18'),(2111,3109,1,460,'Hql',7,'You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','2011-02-04 20:31:08'),(2112,3110,1,57,'Iptables',7,'You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','2011-02-04 20:31:08'),(2113,3101,1,24,'Flow-Control',7,'You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','2011-01-05 17:02:23'),(2114,3101,1,93,'Assertions',6,'You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','2011-01-05 17:02:23'),(2115,3110,1,51,'Context',6,'You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','2011-01-05 17:05:44'),(2116,3106,1,190,'Dispatcher-Servlet',5,'You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). \n','You\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\nYou\'ll also learn programming idioms for each interface to help you get the most out of it. To keep the number of core collection interfaces manageable, the Java platform doesn\'t provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated optional — a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection — the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set — a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List — an ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section\n','2011-05-01 09:06:18');
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `category`
--

DROP TABLE IF EXISTS `category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `category` (
  `catid` int(11) NOT NULL AUTO_INCREMENT,
  `articlecategory` varchar(50) CHARACTER SET utf8 DEFAULT NULL,
  PRIMARY KEY (`catid`)
) ENGINE=InnoDB AUTO_INCREMENT=4106 DEFAULT CHARSET=utf8 COLLATE=utf8_turkish_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `category`
--

LOCK TABLES `category` WRITE;
/*!40000 ALTER TABLE `category` DISABLE KEYS */;
INSERT INTO `category` VALUES (4101,'Java SE'),(4102,'Spring'),(4103,'Hibernate'),(4104,'Tomcat'),(4105,'zahide');
/*!40000 ALTER TABLE `category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `comments`
--

DROP TABLE IF EXISTS `comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `comments` (
  `commentid` int(11) NOT NULL AUTO_INCREMENT,
  `articleid` int(11) NOT NULL,
  `isactivated` tinyint(1) DEFAULT '0',
  `isadmin` tinyint(1) DEFAULT '0',
  `commenttext` mediumtext CHARACTER SET utf8,
  `sender` varchar(100) CHARACTER SET utf8 DEFAULT NULL,
  `senderip` varchar(50) CHARACTER SET utf8 DEFAULT NULL,
  `sendermail` varchar(50) CHARACTER SET utf8 DEFAULT NULL,
  `senddate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`commentid`)
) ENGINE=InnoDB AUTO_INCREMENT=258 DEFAULT CHARSET=utf8 COLLATE=utf8_turkish_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comments`
--

LOCK TABLES `comments` WRITE;
/*!40000 ALTER TABLE `comments` DISABLE KEYS */;
INSERT INTO `comments` VALUES (1,2101,1,0,'güzel olmus','eko',NULL,'dj_boy2010@yahoo.com','2010-10-13 20:39:03'),(2,2101,1,0,'kotu olmus','bilo',NULL,'dj_boy2010@yahoo.com','2010-10-13 20:39:03'),(3,2101,1,0,'normal olmus','maho',NULL,'dj_boy2010@yahoo.com','2010-10-13 20:39:03'),(4,2102,1,0,'frfrf','tee',NULL,'dj_boy2010@yahoo.com','2010-10-14 13:20:29'),(5,2102,1,0,'gttwg','45h6',NULL,'dj_boy2010@yahoo.com','2010-10-14 13:20:29'),(6,2102,1,0,'wgegt','h636',NULL,'dj_boy2010@yahoo.com','2010-10-14 13:20:29'),(7,2102,1,0,'tgtgtg66','786uı',NULL,'dj_boy2010@yahoo.com','2010-10-14 13:20:29'),(8,2101,1,0,'aaaaa','isimsiz bilo','127.0.0.1','asa','2010-10-18 18:07:21'),(9,2103,1,0,'dşcmşdcmdlkcmedced','isimsiz kahraman','127.0.0.1','adsd','2010-10-18 18:17:23'),(10,2104,1,0,'xcxcxcxc','isimsiz','127.0.0.1','xc','2010-10-20 20:57:54'),(11,2104,1,0,'güzel olmus,eline sağlık...','ali ekber çelik','127.0.0.1','aekbercelik@gmail.com','2010-10-20 20:58:24'),(12,2102,1,0,'Directory Package The javax.naming package to provide functionality for accessing directory services in addition to naming services. This package allows applications to retrieve associated with objects stored in the directory and to search for objects using specified attributes. The Directory Context The DirContextinterface represents a directory context. DirContext also behaves as a naming context by extending the getAttributes()to retrieve the attributes associated with a directory entry (for which you supply the name). ','ali ekber celik','127.0.0.1','ali.celik@obss.com.tr','2010-10-20 21:04:25'),(13,2102,1,0,'Directory Package The javax.naming package to provide functionality for accessing directory services in addition to naming services. This package allows applications to retrieve associated with objects stored in the directory and to search for objects using specified attributes. The Directory Context The DirContextinterface represents a directory context. DirContext also behaves as a naming context by extending the getAttributes()to retrieve the attributes associated with a directory entry (for which you supply the name). ','ali ekber celik','127.0.0.1','ali.celik@obss.com.tr','2010-10-20 21:08:55'),(14,2102,1,0,'rhbtenbgtrn','isimsiz','127.0.0.1','','2010-10-20 21:09:32'),(16,2104,1,0,'wewdwsdwd','isimsiz','127.0.0.1','','2010-10-23 07:14:08'),(17,2101,1,0,'wdwddwd','isimsiz','127.0.0.1','','2010-10-25 16:57:45'),(18,2101,1,0,'hbtnhtb','isimsiz','127.0.0.1','','2010-10-25 17:12:50'),(19,2101,1,0,'btbtfb ','isimsiz','127.0.0.1','','2010-10-25 17:13:20'),(20,2101,1,0,'güzel olmuss,hayırlı olsun','kahraman','127.0.0.1','sadads','2010-10-29 12:19:21'),(21,2101,1,0,'tg','isimsiz','0:0:0:0:0:0:0:1','gtg','2010-12-04 11:23:22'),(22,2103,1,0,'gece yar?s? denemesiiiii','ali ali','0:0:0:0:0:0:0:1','ali@ali.com','2010-12-05 00:36:41'),(24,2108,1,0,'deneme deneme','dfdff','0:0:0:0:0:0:0:1','fbb@asa.com','2010-12-06 20:52:38'),(25,2103,1,0,'Advantages of Dynamic Code Loading One of the central and unique features of RMI is its ability to download the definition of an object\'s class if the class is not defined in the receiver\'s Java virtual machine. All of the types and behavior of an object, previously available only in a single Java virtual machine, can be transmitted to another, possibly remote, Java virtual machine. RMI passes objects by their actual classes, so the behavior of the objects is not changed when they are sent to another Java virtual machine. This capability enables new types and behaviors to be introduced into a remote Java virtual machine, thus dynamically extending the behavior of an application. The compute engine example in this trail uses this capability to introduce new behavior to a distributed program. Remote Interfaces, Objects, and Methods Like any other Java application, a distributed application built by using Java RMI is made up of interfaces and classes. The interfaces declare methods. The classes implement the methods declared in the interfaces and, perhaps, declare additional methods as well. In a distributed application, some implementations might reside in some Java virtual machines but not others. Objects with methods that can be invoked across Java virtual machines are called remote objects. An object becomes remote by implementing a remote interface, which has the following characteristics: A remote interface extends the interface java.rmi.Remote. Each method of the interface declares java.rmi.RemoteException in its throws clause, in addition to any application-specific exceptions. RMI treats a remote object differently from a non-remote object when the object is passed from one Java virtual machine to another Java virtual machine. Rather than making a copy of the implementation object in the receiving Java virtual machine, RMI passes a remote stub for a remote object. The stub acts as the local representative, or proxy, for the remote object and basically is, to the client, the remote reference. The client invokes a method on the local stub, which is responsible for carrying out the method invocation on the remote object. A stub for a remote object implements the same set of remote interfaces that the remote object implements. This property enables a stub to be cast to any of the interfaces that the remote object implements. However, only those methods defined in a remote interface are available to be called from the receiving Java virtual machine. Creating Distributed Applications by Using RMI Using RMI to develop a distributed application involves these general steps: Designing and implementing the components of your distributed application. Compiling sources. Making classes network accessible. Starting the application. Designing and Implementing the Application Components First, determine your application architecture, including which components are local objects and which components are remotely accessible. This step includes: Defining the remote interfaces. A remote interface specifies the methods that can be invoked remotely by a client. Clients program to remote interfaces, not to the implementation classes of those interfaces. The design of such interfaces includes the determination of the types of objects that will be used as the parameters and return values for these methods. If any of these interfaces or classes do not yet exist, you need to define them as well. Implementing the remote objects. Remote objects must implement one or more remote interfaces. The remote object class may include implementations of other interfaces and methods that are available only locally. If any local classes are to be used for parameters or return values of any of these methods, they must be implemented as well. Implementing the clients. Clients that use remote objects can be implemented at any time after the remote interfaces are defined, including after the remote objects have been deployed. Compiling Sources As with any Java program, you use the javac compiler to compile the source files. The source files contain the declarations of the remote interfaces, their implementations, any other server classes, and the client classes. -------------------------------------------------------------------------------- Note: With versions prior to Java Platform, Standard Edition 5.0, an additional step was required to build stub classes, by using the rmic compiler. However, this step is no longer necessary. -------------------------------------------------------------------------------- Making Classes Network Accessible In this step, you make certain class definitions network accessible, such as the definitions for the remote interfaces and their associated types, and the definitions for classes that need to be downloaded to the clients or servers. Classes definitions are typically made network accessible through a web server. Starting the Application Starting the application includes running the RMI remote object registry, the server, and the client. The rest of this section walks through the steps used to create a compute engine. Building a Generic Compute Engine This trail focuses on a simple, yet powerful, distributed application called a compute engine. The compute engine is a remote object on the server that takes tasks from clients, runs the tasks, and returns any results. The tasks are run on the machine where the server is running. This type of distributed application can enable a number of client machines to make use of a particularly powerful machine or a machine that has specialized hardware. The novel aspect of the compute engine is that the tasks it runs do not need to be defined when the compute engine is written or started. New kinds of tasks can be created at any time and then given to the compute engine to be run.','asas','0:0:0:0:0:0:0:1','aali@aa.com','2010-12-31 20:25:04'),(26,2103,1,0,'oncomplete denemesi...','ekber','0:0:0:0:0:0:0:1','eko@eko.net','2010-12-31 20:38:51'),(27,2101,1,0,'request deneme','as','0:0:0:0:0:0:0:1','sas@aa.com','2010-12-31 22:52:48'),(28,2109,1,0,'hibocudan sevgiler','hibocu','0:0:0:0:0:0:0:1','hi@bo.cu','2011-01-01 00:51:51'),(29,2102,1,0,'yeni yotum seklini daha da güzelle?tirmelisin','ekber','0:0:0:0:0:0:0:1','sass@aa.com','2011-01-02 14:55:10'),(30,2101,1,0,'nolur patlamaaa','ekber','0:0:0:0:0:0:0:1','eko@ejo.net','2011-01-02 15:02:53'),(31,2101,1,0,'The user of a List generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you\'ve used Vector, you\'re familiar with the general flavor of List. Also see The List Interface section. Queue — a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations. Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements\' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see The Queue Interface section. Map — an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. If you\'ve used Hashtable, you\'re already familiar with the basics of Map. Also see The Map Interface section. The last two core collection interfaces are merely sorted versions of Set and Map: SortedSet — a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see The SortedSet Interface section. SortedMap — a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see The SortedMap Interface section. To understand how the sorted interfaces maintain the order of their elements, see the Object Ordering section','deneme','0:0:0:0:0:0:0:1','dene@deneme.com','2011-01-02 17:34:18'),(32,2111,1,0,'denemee','ekber','0:0:0:0:0:0:0:1','eko@eko.net','2011-01-02 21:11:47'),(33,2111,1,0,'denemeler','ekbero','0:0:0:0:0:0:0:1','eko@eko.net','2011-01-02 21:13:37'),(35,2116,1,0,'askerlik bitecek sfk 21','asker eko','127.0.0.1','asker@eko.com','2011-12-30 07:55:33'),(36,2111,1,0,'askerlik mu.cvs.a.e.celik','werty asker','127.0.0.1','eko@eko.com','2011-12-30 08:02:42'),(37,2104,1,0,'memedisno','mehmet ugur celik','127.0.0.1','mamet@mamet.com','2011-12-31 07:30:31'),(39,2115,1,0,'askerli bitttiiiiiiiiiiiiiiiiiii','bilo','127.0.0.1','bilo@bilo.com','2012-01-21 23:10:45'),(40,2106,1,0,'yorum yazanlar?n cok olsun evlat','mu.cvs.a.e.celik','127.0.0.1','ali@ali.com','2012-01-24 15:49:49'),(41,2110,1,0,'askerlik bitermiydi beee','muhabere cavus','127.0.0.1','eko@eko.com','2012-01-25 05:58:12'),(55,2107,1,0,'kalbinde yer ver','müslüm gürses','127.0.0.1','muslum@bilo.com','2012-01-26 17:20:17'),(57,2113,1,0,'mavenli proje hayirli olsun','mavenli','127.0.0.1','eko@eko.com','2012-02-09 18:06:47'),(61,2115,1,0,'deneme diyorum yaaa','deneme','127.0.0.1','a@a.com','2012-02-13 17:16:35'),(62,2112,1,0,'cok sukur cagirdilar,simdi bekliyorum bakalim alacaklar mi :)','akbank','127.0.0.1','eko@eko.com','2012-02-14 15:39:41'),(63,2115,1,0,'sasasasas','xzx','127.0.0.1','zxz@aa.com','2012-02-14 16:52:22'),(65,2116,1,0,'yeni versiyon denemeeeee','ekber','127.0.0.1',NULL,'2012-09-11 19:14:21'),(66,2116,1,0,' If an unsupported operation is invoked, a collection throws an UnsupportedOperationException. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform\'s general-purpose implementations support all of the optional operations. The following list describes the core collection interfaces: Collection â?? the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn\'t provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as Set and List. Also see The Collection Interface section. Set â?? a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student\'s schedule, or the processes running on a machine. See also The Set Interface section. List â?? an ordered collection (sometimes ca','akbank','127.0.0.1',NULL,'2012-09-11 19:55:07'),(67,2116,1,0,'ucuncu yorumuda yaptik...','galatasaray','0:0:0:0:0:0:0:1',NULL,'2012-09-12 09:48:02'),(68,2116,1,0,'denemeci mahonun oglu denemeci mahonun oglu denemeci mahonun oglu denemeci mahonun oglu denemeci mahonun oglu denemeci mahonun oglu','bilocan','0:0:0:0:0:0:0:1',NULL,'2012-09-12 10:07:42'),(69,2113,1,0,'rest style urlleri bi bitirseydim yaaa','donatello','0:0:0:0:0:0:0:1',NULL,'2012-09-13 09:59:48'),(153,2106,1,0,'yeni url ler guzel oldu','zahiddo','0:0:0:0:0:0:0:1',NULL,'2012-09-13 11:02:39'),(155,2105,1,0,'yeni yorum formu daha guzel haciiii','yeni yorum','0:0:0:0:0:0:0:1',NULL,'2012-09-13 14:10:26'),(161,2114,1,0,'ilk yorum benden olsun hadi ','ali ekber','0:0:0:0:0:0:0:1','aa@aa.com','2012-09-14 14:56:11'),(162,2108,1,0,'2e3e32e3','e323e2e2e3','0:0:0:0:0:0:0:1','e23@aa.ccc','2012-09-17 08:09:06'),(163,2114,1,0,'edfececec efeff','aa','0:0:0:0:0:0:0:1','aa@aa.com','2012-09-17 08:15:28'),(164,2104,1,0,'gdfgdfgdg','ffg','127.0.0.1','fgfdgdfg@gg.com','2013-03-01 14:50:40'),(165,2104,1,0,'Yillar sonra comment maili','Ali Ekber Celik','127.0.0.1','dj_boy2010@yahoo.com','2013-03-01 14:55:30'),(166,2116,1,0,'denemememememe','xss','127.0.0.1','sss@aaa.com','2013-03-11 13:37:39'),(167,2116,1,0,'cdcscdc','dcsdcds','127.0.0.1','canali2002@hotmail.com','2013-03-11 13:47:38'),(168,2109,0,0,'olsun bu kez bee','ali ekber',NULL,'ali@ali.com','2013-03-11 14:34:27'),(169,2109,0,0,'zahide denemeler','zaho',NULL,'zaho@zaho.com','2013-03-11 14:36:56'),(179,2112,0,0,'ajax insert','bilo',NULL,'bilo@aa.com','2013-03-11 17:30:31'),(189,2113,0,0,'schalke rovans maci nolacak acaba?','ali ekber',NULL,'ali@ali.com','2013-03-12 16:37:24'),(191,2105,0,1,'schalke 2-3 galatasaray','ali ekber',NULL,'aa@aa.com','2013-03-12 22:17:57'),(192,2107,0,0,'lllkk','asas',NULL,'ssss@aa.com','2013-03-13 16:29:36'),(193,2107,0,0,'','asas',NULL,'ssss@aa.com','2013-03-13 16:29:58'),(194,2107,0,0,'','',NULL,'','2013-03-13 16:30:14'),(195,2107,0,0,'','',NULL,'','2013-03-13 16:30:33'),(196,2107,0,0,'','',NULL,'','2013-03-13 16:57:30'),(197,2107,0,0,'','',NULL,'','2013-03-13 16:57:59'),(198,2107,0,0,'','',NULL,'','2013-03-13 17:22:41'),(199,2107,0,0,'','',NULL,'','2013-03-13 17:25:38'),(200,2107,0,0,'','',NULL,'','2013-03-13 17:28:59'),(201,2107,0,0,'fghj','ghg',NULL,'bnbmnnm@aa.com','2013-03-13 18:28:09'),(202,2107,0,0,'fghj','ghg',NULL,'bnbmnnm@aa.com','2013-03-13 18:48:52'),(206,2105,0,0,'hala oglu site on numara rafiq','mehmet a?aR',NULL,'asar@asar.com','2013-03-15 22:10:31'),(221,2105,0,0,'Therefore, it checks for the presence of a shopping cart even when the buyer sees the book list for the very first time. Scriptlet 4 displays the items in the shopping cart, each one with its own form. If the buyer decides to delete an entry, index.jsp sends a request to the servlet with the hidden parameter do_this set to remove. The sole purpose of the last two scriptlets is to close the curly brackets of ifs and fors. However, notice that the form to ask the servlet to do the checkout is only displayed to the buyer when the shopping cart isn’t empty. If the buyer clicks on the Checkout button, index.jsp will send a request to the servlet with the hidden parameter do_this set to checkout. ','zahide çelik',NULL,'zahidebas@gmail.com','2013-03-19 16:39:31'),(247,2106,0,0,'','',NULL,'','2013-03-23 10:49:58'),(248,2106,0,0,'','',NULL,'','2013-03-23 10:50:27'),(249,2106,0,0,'','',NULL,'','2013-03-23 10:50:37'),(250,2105,0,0,'','',NULL,'','2013-04-21 11:11:50'),(251,2105,0,0,'','',NULL,'','2013-04-21 11:16:07'),(252,2105,0,0,'','',NULL,'','2013-04-21 12:24:01'),(253,2105,0,0,'','',NULL,'','2013-04-21 12:24:07'),(254,2105,0,0,'','',NULL,'','2013-04-21 12:24:39'),(255,2105,0,0,'','',NULL,'','2013-04-21 12:51:31'),(256,2105,0,0,'','',NULL,'','2013-04-21 13:51:27'),(257,2105,0,0,'','',NULL,'','2013-04-23 09:52:36');
/*!40000 ALTER TABLE `comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `subcategory`
--

DROP TABLE IF EXISTS `subcategory`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `subcategory` (
  `subcatid` int(11) NOT NULL AUTO_INCREMENT,
  `catid` int(11) DEFAULT NULL,
  `subcategoryname` varchar(50) CHARACTER SET latin1 DEFAULT NULL,
  PRIMARY KEY (`subcatid`)
) ENGINE=InnoDB AUTO_INCREMENT=3111 DEFAULT CHARSET=utf8 COLLATE=utf8_turkish_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `subcategory`
--

LOCK TABLES `subcategory` WRITE;
/*!40000 ALTER TABLE `subcategory` DISABLE KEYS */;
INSERT INTO `subcategory` VALUES (3101,4101,'Collections'),(3102,4101,'File IO'),(3103,4101,'OOP'),(3104,4102,'Spring AOP'),(3105,4102,'Spring Security'),(3106,4102,'Spring MVC'),(3107,4102,'Spring Web Services'),(3108,4103,'Criteria Api'),(3109,4104,'Mapping'),(3110,4104,'Port Redirecting');
/*!40000 ALTER TABLE `subcategory` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tag`
--

DROP TABLE IF EXISTS `tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tag` (
  `tagid` int(11) NOT NULL AUTO_INCREMENT,
  `tagname` varchar(100) DEFAULT NULL,
  `tagarticleid` int(11) NOT NULL,
  PRIMARY KEY (`tagid`)
) ENGINE=MyISAM AUTO_INCREMENT=12 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tag`
--

LOCK TABLES `tag` WRITE;
/*!40000 ALTER TABLE `tag` DISABLE KEYS */;
INSERT INTO `tag` VALUES (2,'collections',2104),(1,'java',2104),(5,'java',2116),(4,'java',2105),(3,'ejb3',2105),(11,'spring',2108),(10,'hibernate',2116),(9,'spring',2105),(8,'hibernate',2105),(7,'spring',2104),(6,'hibernate',2107);
/*!40000 ALTER TABLE `tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user` (
  `user_name` varchar(15) NOT NULL,
  `user_pass` varchar(128) NOT NULL,
  PRIMARY KEY (`user_name`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES ('ekber','202cb962ac59075b964b07152d234b70');
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_rate`
--

DROP TABLE IF EXISTS `user_rate`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user_rate` (
  `rateid` int(11) NOT NULL AUTO_INCREMENT,
  `ratedarticleid` int(11) NOT NULL,
  `rate` int(11) NOT NULL,
  `raterip` varchar(64) DEFAULT NULL,
  `ratedate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`rateid`)
) ENGINE=InnoDB AUTO_INCREMENT=254 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_rate`
--

LOCK TABLES `user_rate` WRITE;
/*!40000 ALTER TABLE `user_rate` DISABLE KEYS */;
INSERT INTO `user_rate` VALUES (4,2116,4,'127.0.0.1','2011-01-25 09:29:12'),(5,2115,1,'127.0.0.1','2011-01-25 11:32:25'),(6,2112,3,'127.0.0.1','2011-01-25 11:32:45'),(7,2115,1,'127.0.0.1','2011-01-25 11:34:14'),(8,2109,4,'127.0.0.1','2011-01-25 14:50:20'),(9,2110,4,'127.0.0.1','2011-01-25 14:51:19'),(10,2111,5,'127.0.0.1','2011-01-25 14:51:32'),(11,2109,3,'127.0.0.1','2011-01-25 14:51:45'),(12,2108,3,'127.0.0.1','2011-01-25 14:51:57'),(13,2104,5,'127.0.0.1','2011-01-25 14:52:06'),(14,2105,2,'127.0.0.1','2011-01-25 14:52:18'),(15,2106,3,'127.0.0.1','2011-01-25 14:52:29'),(16,2109,2,'127.0.0.1','2011-01-26 06:40:03'),(17,2102,5,'127.0.0.1','2011-01-26 11:44:15'),(18,2114,4,'127.0.0.1','2011-01-26 13:31:23'),(19,2113,2,'127.0.0.1','2011-01-26 13:50:01'),(20,2115,5,'127.0.0.1','2011-01-26 13:50:11'),(21,2116,5,'127.0.0.1','2011-01-26 13:52:01'),(22,2115,5,'127.0.0.1','2011-01-26 13:53:41'),(23,2106,5,'127.0.0.1','2011-02-16 08:48:21'),(24,2108,1,'127.0.0.1','2011-03-08 09:26:54'),(25,2116,4,'127.0.0.1','2011-07-13 16:52:40'),(26,2111,2,'127.0.0.1','2011-07-15 18:30:44'),(27,2113,1,'127.0.0.1','2011-07-15 18:31:17'),(28,2116,2,'127.0.0.1','2011-07-15 18:31:44'),(29,2116,5,'127.0.0.1','2011-07-15 18:42:07'),(30,2102,2,'127.0.0.1','2011-07-15 18:53:39'),(31,2115,1,'127.0.0.1','2011-07-19 18:32:36'),(32,2101,1,'127.0.0.1','2011-07-20 16:13:42'),(33,2115,5,'127.0.0.1','2011-07-20 16:15:03'),(34,2108,1,'127.0.0.1','2011-07-21 15:23:58'),(35,2108,1,'127.0.0.1','2011-07-21 15:33:28'),(36,2108,1,'127.0.0.1','2011-07-21 15:40:26'),(37,2108,5,'127.0.0.1','2011-07-21 16:10:32'),(38,2109,1,'127.0.0.1','2011-07-21 16:14:13'),(39,2112,4,'127.0.0.1','2011-07-21 17:51:33'),(40,2110,3,'127.0.0.1','2011-12-27 22:21:33'),(41,2105,5,'127.0.0.1','2011-12-30 07:41:48'),(42,2116,3,'127.0.0.1','2011-12-30 07:55:45'),(43,2116,1,'127.0.0.1','2011-12-30 08:03:18'),(44,2116,1,'127.0.0.1','2011-12-30 20:59:15'),(45,2116,1,'127.0.0.1','2011-12-30 22:19:09'),(46,2116,1,'127.0.0.1','2011-12-31 08:03:33'),(47,2115,4,'127.0.0.1','2012-01-21 20:57:03'),(48,2115,2,'127.0.0.1','2012-01-21 23:06:00'),(49,2115,1,'127.0.0.1','2012-01-21 23:11:00'),(50,2108,1,'127.0.0.1','2012-01-23 19:37:03'),(51,2115,1,'127.0.0.1','2012-01-23 19:49:43'),(52,2110,1,'127.0.0.1','2012-01-23 19:50:06'),(53,2109,4,'127.0.0.1','2012-01-23 19:52:02'),(54,2111,1,'127.0.0.1','2012-01-23 20:00:10'),(55,2110,5,'127.0.0.1','2012-01-23 20:04:32'),(56,2109,5,'127.0.0.1','2012-01-23 20:04:56'),(58,2103,5,'127.0.0.1','2012-01-23 20:31:35'),(59,2109,5,'127.0.0.1','2012-01-23 20:37:33'),(60,2110,3,'127.0.0.1','2012-01-23 20:38:06'),(61,2112,2,'127.0.0.1','2012-01-23 20:38:25'),(62,2113,5,'127.0.0.1','2012-01-23 20:38:44'),(63,2111,5,'127.0.0.1','2012-01-23 20:39:03'),(64,2107,5,'127.0.0.1','2012-01-23 20:39:41'),(65,2115,1,'127.0.0.1','2012-01-24 15:55:12'),(66,2106,1,'127.0.0.1','2012-01-24 15:57:57'),(67,2110,5,'127.0.0.1','2012-01-24 18:19:28'),(68,2108,5,'127.0.0.1','2012-01-24 18:19:54'),(69,2109,1,'127.0.0.1','2012-01-24 18:30:30'),(70,2111,1,'127.0.0.1','2012-01-24 19:22:15'),(71,2110,1,'127.0.0.1','2012-01-24 19:40:28'),(72,2106,1,'127.0.0.1','2012-01-24 19:41:07'),(73,2105,1,'127.0.0.1','2012-01-24 19:42:09'),(74,2105,1,'127.0.0.1','2012-01-24 19:43:05'),(75,2105,1,'127.0.0.1','2012-01-24 19:44:47'),(76,2105,1,'127.0.0.1','2012-01-24 19:50:13'),(77,2103,1,'127.0.0.1','2012-01-24 20:10:45'),(78,2104,5,'127.0.0.1','2012-01-24 20:11:30'),(79,2102,1,'127.0.0.1','2012-01-24 20:48:39'),(80,2113,1,'127.0.0.1','2012-01-24 20:51:27'),(81,2111,1,'127.0.0.1','2012-01-25 06:05:13'),(82,2110,1,'127.0.0.1','2012-01-25 06:07:41'),(83,2110,1,'127.0.0.1','2012-01-25 06:14:59'),(84,2110,1,'127.0.0.1','2012-01-25 06:17:54'),(85,2110,5,'127.0.0.1','2012-01-25 20:02:04'),(86,2101,4,'127.0.0.1','2012-01-26 17:21:16'),(87,2107,4,'127.0.0.1','2012-01-26 17:22:23'),(88,2112,3,'127.0.0.1','2012-01-31 08:31:28'),(89,2110,1,'127.0.0.1','2012-01-31 08:32:58'),(90,2113,2,'127.0.0.1','2012-02-02 10:51:56'),(91,2110,4,'127.0.0.1','2012-02-07 20:17:07'),(92,2111,4,'127.0.0.1','2012-02-07 21:13:55'),(93,2111,1,'127.0.0.1','2012-02-07 21:22:19'),(94,2111,5,'127.0.0.1','2012-02-07 21:23:37'),(95,2111,3,'127.0.0.1','2012-02-07 21:25:29'),(96,2109,2,'127.0.0.1','2012-02-07 21:51:00'),(97,2111,3,'127.0.0.1','2012-02-07 21:52:04'),(98,2111,5,'127.0.0.1','2012-02-07 21:54:06'),(99,2111,4,'127.0.0.1','2012-02-07 22:00:15'),(100,2111,5,'127.0.0.1','2012-02-07 22:01:56'),(101,2112,4,'127.0.0.1','2012-02-07 22:04:02'),(102,2112,5,'127.0.0.1','2012-02-07 22:09:51'),(103,2110,1,'127.0.0.1','2012-02-07 22:10:10'),(104,2109,4,'127.0.0.1','2012-02-08 13:47:35'),(105,2101,3,'127.0.0.1','2012-02-08 13:59:23'),(106,2116,1,'127.0.0.1','2012-02-08 14:00:40'),(107,2105,5,'127.0.0.1','2012-02-08 14:23:18'),(108,2113,5,'127.0.0.1','2012-02-08 14:26:36'),(109,2113,5,'127.0.0.1','2012-02-08 20:06:55'),(110,2102,5,'127.0.0.1','2012-02-08 20:10:17'),(111,2103,2,'127.0.0.1','2012-02-09 17:47:18'),(112,2114,3,'127.0.0.1','2012-02-09 17:57:10'),(113,2113,4,'127.0.0.1','2012-02-09 18:07:18'),(114,2112,1,'127.0.0.1','2012-02-09 19:47:03'),(115,2113,5,'127.0.0.1','2012-02-12 23:27:02'),(116,2115,1,'127.0.0.1','2012-02-12 23:27:32'),(117,2106,1,'127.0.0.1','2012-02-12 23:31:59'),(118,2112,1,'127.0.0.1','2012-02-12 23:32:48'),(119,2116,1,'127.0.0.1','2012-02-13 00:21:45'),(120,2113,1,'127.0.0.1','2012-02-13 00:23:23'),(121,2103,5,'127.0.0.1','2012-02-13 00:23:40'),(122,2103,1,'127.0.0.1','2012-02-13 00:25:41'),(123,2109,1,'127.0.0.1','2012-02-13 00:25:53'),(124,2104,1,'127.0.0.1','2012-02-13 00:32:15'),(125,2115,5,'127.0.0.1','2012-02-13 16:59:05'),(126,2115,5,'127.0.0.1','2012-02-13 17:10:01'),(127,2115,5,'127.0.0.1','2012-02-13 17:16:47'),(128,2115,5,'127.0.0.1','2012-02-13 17:44:03'),(129,2111,5,'127.0.0.1','2012-02-13 17:44:14'),(130,2115,5,'127.0.0.1','2012-02-14 15:36:51'),(131,2107,5,'127.0.0.1','2012-02-14 15:37:25'),(132,2116,5,'127.0.0.1','2012-02-14 15:38:30'),(133,2116,5,'127.0.0.1','2012-02-14 15:39:48'),(134,2112,5,'127.0.0.1','2012-02-14 16:04:59'),(135,2115,5,'127.0.0.1','2012-02-14 17:10:01'),(136,2113,5,'127.0.0.1','2012-02-16 15:08:47'),(137,2112,5,'127.0.0.1','2012-05-14 19:24:54'),(138,2113,5,'127.0.0.1','2012-05-20 12:23:46'),(139,2111,4,'127.0.0.1','2012-05-23 19:16:58'),(140,2115,5,'127.0.0.1','2012-05-28 20:10:31'),(141,2105,5,'127.0.0.1','2012-06-05 19:13:03'),(142,2105,5,'127.0.0.1','2012-06-05 19:13:30'),(143,2105,5,'127.0.0.1','2012-06-05 19:18:48'),(144,2116,1,'127.0.0.1','2012-06-05 19:19:30'),(145,2105,5,'127.0.0.1','2012-06-05 19:19:35'),(146,2116,5,'127.0.0.1','2012-06-05 19:20:20'),(147,2105,1,'127.0.0.1','2012-06-05 19:22:51'),(148,2115,1,'127.0.0.1','2012-06-05 19:24:33'),(149,2102,2,'127.0.0.1','2012-08-27 20:28:47'),(150,2113,5,'127.0.0.1','2012-08-27 20:29:16'),(151,2110,5,'0:0:0:0:0:0:0:1','2012-08-29 08:32:15'),(152,2116,1,'0:0:0:0:0:0:0:1','2012-08-29 08:50:05'),(153,2110,5,'0:0:0:0:0:0:0:1','2012-09-11 13:36:06'),(154,2116,4,'127.0.0.1','2012-09-11 13:48:29'),(155,2110,5,'127.0.0.1','2012-09-11 14:18:20'),(156,2110,4,'127.0.0.1','2012-09-11 14:34:25'),(157,2110,5,'127.0.0.1','2012-09-11 14:35:12'),(158,2116,5,'127.0.0.1','2012-09-11 14:48:51'),(159,2116,1,'127.0.0.1','2012-09-11 14:50:56'),(160,2109,5,'127.0.0.1','2012-09-11 14:57:11'),(161,2111,5,'127.0.0.1','2012-09-11 14:58:06'),(162,2109,5,'127.0.0.1','2012-09-11 14:58:25'),(163,2109,1,'127.0.0.1','2012-09-11 18:08:18'),(164,2109,1,'127.0.0.1','2012-09-11 19:30:02'),(165,2116,5,'127.0.0.1','2012-09-11 20:02:38'),(166,2113,5,'127.0.0.1','2012-09-11 20:04:44'),(167,2116,5,'0:0:0:0:0:0:0:1','2012-09-12 06:15:33'),(168,2116,5,'0:0:0:0:0:0:0:1','2012-09-12 06:51:24'),(169,2116,5,'0:0:0:0:0:0:0:1','2012-09-12 06:53:07'),(170,2116,5,'0:0:0:0:0:0:0:1','2012-09-12 06:53:28'),(171,2116,5,'0:0:0:0:0:0:0:1','2012-09-12 06:53:44'),(172,2116,5,'0:0:0:0:0:0:0:1','2012-09-12 06:57:51'),(173,2116,5,'0:0:0:0:0:0:0:1','2012-09-12 06:58:03'),(174,2116,5,'0:0:0:0:0:0:0:1','2012-09-12 06:58:19'),(175,2116,5,'0:0:0:0:0:0:0:1','2012-09-12 06:58:36'),(176,2116,5,'0:0:0:0:0:0:0:1','2012-09-12 09:46:42'),(177,2116,5,'0:0:0:0:0:0:0:1','2012-09-12 09:58:27'),(178,2116,1,'0:0:0:0:0:0:0:1','2012-09-12 10:09:21'),(179,2109,5,'0:0:0:0:0:0:0:1','2012-09-12 13:53:41'),(180,2112,1,'0:0:0:0:0:0:0:1','2012-09-12 14:35:36'),(181,2109,5,'0:0:0:0:0:0:0:1','2012-09-12 18:02:10'),(182,2116,5,'0:0:0:0:0:0:0:1','2012-09-12 18:17:33'),(183,2104,1,'0:0:0:0:0:0:0:1','2012-09-13 06:29:30'),(184,2104,1,'0:0:0:0:0:0:0:1','2012-09-13 06:34:31'),(185,2105,5,'0:0:0:0:0:0:0:1','2012-09-13 06:54:13'),(186,2105,1,'0:0:0:0:0:0:0:1','2012-09-13 06:58:14'),(187,2105,1,'0:0:0:0:0:0:0:1','2012-09-13 06:58:23'),(188,2111,5,'0:0:0:0:0:0:0:1','2012-09-13 08:36:03'),(189,2111,5,'0:0:0:0:0:0:0:1','2012-09-13 08:36:25'),(190,2111,3,'0:0:0:0:0:0:0:1','2012-09-13 08:36:34'),(191,2111,5,'0:0:0:0:0:0:0:1','2012-09-13 08:47:27'),(192,2104,5,'0:0:0:0:0:0:0:1','2012-09-13 08:47:54'),(193,2103,5,'0:0:0:0:0:0:0:1','2012-09-13 08:58:12'),(194,2104,5,'0:0:0:0:0:0:0:1','2012-09-13 08:58:54'),(195,2104,1,'0:0:0:0:0:0:0:1','2012-09-13 09:57:29'),(196,2113,1,'0:0:0:0:0:0:0:1','2012-09-13 09:58:45'),(197,2112,5,'0:0:0:0:0:0:0:1','2012-09-13 10:59:07'),(198,2106,5,'0:0:0:0:0:0:0:1','2012-09-13 11:00:38'),(199,2106,5,'0:0:0:0:0:0:0:1','2012-09-13 11:05:55'),(200,2106,5,'0:0:0:0:0:0:0:1','2012-09-13 11:38:24'),(201,2105,5,'0:0:0:0:0:0:0:1','2012-09-13 13:03:11'),(202,2105,5,'0:0:0:0:0:0:0:1','2012-09-13 14:17:25'),(203,2105,5,'0:0:0:0:0:0:0:1','2012-09-13 14:51:13'),(204,2105,5,'0:0:0:0:0:0:0:1','2012-09-13 15:00:20'),(205,2105,1,'0:0:0:0:0:0:0:1','2012-09-14 06:15:24'),(206,2105,1,'0:0:0:0:0:0:0:1','2012-09-14 06:24:32'),(207,2105,1,'0:0:0:0:0:0:0:1','2012-09-14 08:50:39'),(208,2105,1,'0:0:0:0:0:0:0:1','2012-09-14 12:25:33'),(209,2116,5,'0:0:0:0:0:0:0:1','2012-09-14 12:50:09'),(210,2106,1,'0:0:0:0:0:0:0:1','2012-09-14 12:58:37'),(211,2114,5,'0:0:0:0:0:0:0:1','2012-09-14 14:57:15'),(212,2114,5,'0:0:0:0:0:0:0:1','2012-09-14 14:59:38'),(213,2114,1,'0:0:0:0:0:0:0:1','2012-09-14 18:20:49'),(214,2110,5,'0:0:0:0:0:0:0:1','2012-09-17 06:22:44'),(215,2108,5,'0:0:0:0:0:0:0:1','2012-09-17 08:08:51'),(216,2114,5,'0:0:0:0:0:0:0:1','2012-09-17 08:15:17'),(217,2111,1,'0:0:0:0:0:0:0:1','2012-09-17 11:24:12'),(218,2106,1,'0:0:0:0:0:0:0:1','2012-09-17 11:24:37'),(219,2105,5,'0:0:0:0:0:0:0:1','2012-09-17 13:47:29'),(220,2105,1,'0:0:0:0:0:0:0:1','2012-09-17 18:33:35'),(221,2109,1,'127.0.0.1','2013-03-01 09:37:32'),(222,2105,1,'127.0.0.1','2013-03-01 13:36:02'),(223,2108,2,'127.0.0.1','2013-03-02 08:21:13'),(224,2108,2,'127.0.0.1','2013-03-02 08:29:53'),(225,2115,2,'127.0.0.1','2013-03-03 23:02:48'),(226,2101,2,'127.0.0.1','2013-03-03 23:03:48'),(227,2102,5,'127.0.0.1','2013-03-03 23:04:04'),(228,2105,3,'127.0.0.1','2013-03-04 08:12:13'),(229,2114,5,'127.0.0.1','2013-03-04 11:57:25'),(230,2114,1,'127.0.0.1','2013-03-04 11:57:34'),(231,2109,1,'127.0.0.1','2013-03-04 13:26:24'),(232,2109,4,'127.0.0.1','2013-03-04 14:14:04'),(233,2109,5,'127.0.0.1','2013-03-04 14:36:34'),(234,2105,5,'127.0.0.1','2013-03-04 21:41:21'),(235,2105,4,'127.0.0.1','2013-03-06 19:32:21'),(236,2116,5,'127.0.0.1','2013-03-06 19:51:15'),(237,2105,4,'127.0.0.1','2013-03-06 20:04:55'),(238,2114,4,'127.0.0.1','2013-03-06 22:01:21'),(239,2106,1,'127.0.0.1','2013-03-07 17:06:29'),(240,2114,1,'127.0.0.1','2013-03-08 19:00:39'),(241,2105,4,'127.0.0.1','2013-03-09 12:00:15'),(242,2113,4,'127.0.0.1','2013-03-12 16:44:51'),(243,2105,1,'127.0.0.1','2013-03-12 23:26:20'),(244,2110,4,'127.0.0.1','2013-03-13 23:18:52'),(245,2112,4,'127.0.0.1','2013-03-14 13:51:21'),(246,2105,4,'127.0.0.1','2013-03-17 08:31:39'),(247,2105,5,'127.0.0.1','2013-03-17 09:22:43'),(248,2105,2,'127.0.0.1','2013-03-19 16:40:16'),(249,2105,2,'127.0.0.1','2013-03-22 21:42:29'),(250,2105,3,'127.0.0.1','2013-03-22 21:52:19'),(251,2105,3,'127.0.0.1','2013-04-20 21:08:06'),(252,2113,2,'127.0.0.1','2013-04-20 21:28:47'),(253,2105,1,'127.0.0.1','2013-04-23 09:53:07');
/*!40000 ALTER TABLE `user_rate` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_role`
--

DROP TABLE IF EXISTS `user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user_role` (
  `user_name` varchar(15) NOT NULL,
  `role_name` varchar(15) NOT NULL,
  PRIMARY KEY (`user_name`,`role_name`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_role`
--

LOCK TABLES `user_role` WRITE;
/*!40000 ALTER TABLE `user_role` DISABLE KEYS */;
INSERT INTO `user_role` VALUES ('ekber','admin');
/*!40000 ALTER TABLE `user_role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2013-08-16  0:32:43
